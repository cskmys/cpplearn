== Indirection

As {cpp} is a strongly typed language, even the references and pointers have a type.
They cannot simply point to anything.
They'll need to point to the target type that was mention during declaration.

=== Reference

A reference is an alias for a target variable.
Any action done on the reference is actually being done on the target.
No need of special punctuation to indicate this, it can be just used as if the actual target is being used.

A reference can only be set to a target when declaring it, and it cannot be made to refer to something else.

=== Pointers

Pointers hold the address of the target variable, or it can also hold nothing meaning point to nowhere.
To point to nowhere you can use 0 or the keyword `nullptr`
[TIP]
====
Always use `nullptr` keyword for null pointer.
====

It can be uninitialized, initialized, and reinitialized whenever required.
You should never leave a pointer uninitialized coz it can take a junk value which might get wrongly interpreted as address, and there is no way to check for this.
Hence, if you are yet to initialize your pointer, then initialize it to `nullptr` during declaration.
This way you can do a null check before using the pointer.
[TIP]
====
If you want to make sure that your pointer is never null/invalid, then probably you are better off using a reference.
====

Special punctuation is required to perform action on the target(called dereferencing), otherwise the operation performed will be interpreted as being performed on the address of the target.

== Const

To commit to a compiler that you won't change something:

[WARNING]
====
Make sure to have `const` correctness from the very beginning.
Achieving `const` correctness later is often tedious and difficult.
====

[TIP]
====
Your default way to write all variables, arguments, functions, members etc. should be with `const` until you no longer can.
====

* When declaring a local variable
+
----
int const val = 1.717 // read as "constant integer"
----

* When passing a parameter:

** Pass by value
+
----
int foo(int const b);
----
+
here `b` is copied anyway, so even if it changes, there's no harm to the original value.
however, if you still want to conceptually make sure that the logic doesn't need to make any changes to any parameters, you can do this way.

** Pass by reference
+
----
int foo(int const& b); // read as "constant reference to integer"
----
+
here `b` is reference, hence it is not copied and there is a potential for modification of the original value.
Adding `const` before a reference, will make sure that the original value is never modified via this reference.
+
Reference to a const is not allowed coz the reference unless declared as const should allow the change of target value but if the target value is a const then there's no way that it can be changed.
Therefore, reference to a const is a paradox and hence, it is not allowed.
+
const reference to a const value comes within the above const reference to value as if the reference is constant, then there is no way that you can change it regardless of the target is constant or not.
Hence, we do not have a special case for this.

** Pass by pointer
+
You can pass

*** `const` pointer to a target:
+
----
int foo(int * const b); // read as "constant pointer to integer"
----
+
same logic as const reference.

*** Pointer to `const` target:
+
----
int foo(int const * b); //  read as "pointer to constant integer"
----
+
Here pointer can be reassigned to point to another address but the target that it points to must be a constant.

*** `const` pointer to `const`
+
----
int foo(const int * const b); // read as "constant pointer to constant integer"
----
+
here you cannot change both the pointer and the data that it points to.

* When using a member function:
+
----
int foo() const;
----
+
when you have a member function, it can directly access member variables without passing them as arguments.
If something was passed as argument, then we can use `const` with argument to make sure that it is not modified.
To make sure that member function doesn't modify member variable, we qualify the member function itself as `const`.

=== Style
`const` can be written before or after, for example:
----
const int ci = 3; // const-before style
----
is same as:
----
int const ci = 3; // const-after style
----
for the compiler.

For us, using const-after enhances readability as shown previously, especially when using with pointers.
You just need to read it from lhs to rhs.

The only confusing exception would be "const reference to a target" which is written as:
----
int const & cri = i;
----
instead of:
----
int & const cri = i;
----
But, as "const reference to const target" is covered under "const reference to target", and as there is no "reference to a const target", we don't need to worry about this.
If we remember just this one exception to style, it is good enough.

[TIP]
====
Instead of writing:
----
int const & cri = i;
----
and reading it as reference to const int,
write it as:
----
int const& cri = i;
----
so that you can read `const&` as one word "const-reference" and hence read `int const&` as "const-reference to int".
====

== Memory Management

=== Free store

[NOTE]
====
Stack & local store are used interchangeably.
Similarly, Heap & free store as well.
====

Local variables are allocated memory on stack when they are declared, and this memory is cleared when you return from the function in other words, the scope of the local variable ends.

If you want to store variables beyond the scope of the function in which they are declared:

* Create the variable on the heap, and keep the address to the heap location on the stack.
+
This is automatically done by using `new` operator to instantiate the object.
Now whatever, the constructor does it will be doing it on the heap.
+
[NOTE]
====
Syntax will vary a little when you are doing `new` on raw array.
But, when you are using modern {cpp}, you should never use raw arrays, and use arrays from STL.
====

* When you exit the function, you'll need to make sure that the address to the heap location is returned coz after exit the stack will be cleared, and the address of the heap location currently stored on the stack, will be lost.
+
This is done by having a pointer as the return type.

When you are done, and you do not need it anymore, you can manually call `delete` operator to trigger the destructor and then deallocate all the memory that was allocated on the heap.
[WARNING]
====
The local pointer variable that was used to call `delete` will still contain the address to the deallocated heap location.
So don't forget to reinitialize it to `nullptr` so that null checks can protect you.
If you forget to reinitialize it to `nullptr`, then null checks cannot protect you, and you'll end up, dereferencing an illegal memory location, and reading junk and/or causing code crash.
====
[NOTE]
====
Doing `delete` on `nullptr` doesn't cause code crash.
====

Using `new` and `delete` is a manual way of memory management which is very tedious and error-prone.
There are several error scenarios:

* The local variable which contains the pointer goes out of scope, then you lose access to the object
* Delete too soon meaning dereferencing an invalid pointer
* Delete twice meaning doing delete on an invalid address
* Never delete which will lead to memory leaks
* Someone copies that pointer, and them using that pointer can lead to a host of issues mentioned above.

Thumb rules for manual memory management

* Whenever you create an object on heap, keep its pointer inside another object which calls delete, on all the pointers it has been given, in its destructor so that all pointers are cleaned up when it goes out of scope.

* Don't do shallow copies of the object, do deep copies using copy constructor.
This will prevent the copy pointer dereferencing the location after it has been deallocated via the original pointer.

* Overload copy assignment operator to delete existing data and (deep) copy the new data that is being assigned.
When you simply use the assignment operator without overloading it as mentioned above, the current pointer will take in the address of the pointer that is being assigned to it and its own address is lost.
Once the address is lost, you can never free the memory.

* If the resource in an object is expensive, deleting it while deleting the object and recreating it while creating a new object can be expensive.
To avoid this, we can `move` it to another object using move constructor.

* If the resource in an object is expensive, unlike overload copy assignment operator where you delete everything, and (deep) copy, you delete and (deep) copy only the inexpensive part, and you `move` the expensive resource.

Hence, to make manual memory management less error-prone you'll need to write at least five functions some of which are complicated, and you will have to check for things such as self-assignment etc.
All these make manual memory management painful.

So the best solution is:

* use STL as much as possible
* design your class in such a way that you stick to local store as much as possible

