= Notes

Never leave any variables uninitialized.

Never forget return statements.

Use `default` for default constructors to initialize with all default values instead of junk.

Use safe casts instead of C-style round-bracketed cast which is unsafe.

Never ever write `using` statements in a header file.

Use {cpp} scoped enums instead of C-style enums.

In modern {cpp} the only preprocessor you'll probably need is `include`.

Use references and smart pointers instead of C-style pointers.

Declare references that you use to prevent a copy but do not want to change the original instance, as `const&` i.e. const references.

Declare member functions as `const` to make sure that they do not change the member variable.

If you are not enabling compiler optimizations, use inline functions.

Avoid calling code that has side effect in the condition clause of statement with boolean/logical operators.

Always do a check to ensure that denominator is non-zero when doing division.

For readability do not use shift operators in place of arithmetic operators when performing multiplication/division by 2.

To provide access to a private member, public getter should be your first choice.
Use friend if and only if you think adding a public getter is going to unnecessarily expose the variable to the whole world when in fact it is required by only one class.

Do not use `protected` member variables as it tightly bind the base class with the inherited class.
To have a decoupling put these `protected` member variables under `private` and write a `protected`/`public` getter for them in the base class, and use these getters in the inherited class.

While using templates, if a particular operator doesn't make sense for the data type that you want to use in the template, then do template specialization instead of implementing the operator in the data type.

For indirection, references should be your first choice instead of pointers.

Always use `nullptr` for null pointer instead of 0.

Always do a null check when using pointers.

If you want your indirection to never be invalid/null, then use references.

Your default way to write all variables, arguments, functions, members etc. should be with `const` until you no longer can.

To enhance readability use `const`-after style to write your constants.
Remember, `const`-after style is read from right to left(with the exception "const reference to target").

Never use raw arrays, use arrays from STL.

As soon as you mark a class's function as `virtual` mark its destructor as `virtual` as well.

Do not ever pass a derived class by value to base class parameter in a function call.
Always, pass the derived class via a reference or a pointer to the base class parameter in a function call to avoid slicing.

Don't ever use C-style casts, use {cpp}'s `static_cast` when you are absolutely sure of the casting and `dynamic_cast` when you are not very sure.

After doing `dynamic_cast` of pointers do not forget to check for null.

Do not ever use `const_cast`.

If you want an array that expands use `std::vector` otherwise use `std::array`.

When you think you want to use `std::list` for performance reasons, start with `std::vector`  measure, switch to `std::list` and compare its performance with `std::vector`.

Try to write your code in such a way that it is easy to switch containers.
In other words, use iterators, `auto`, and STL algorithms etc.

Forget about function pointers and function objects, use lambdas instead.

Just capture everything by value/reference in the capture clause, and then list whatever you want to do otherwise.

In the lambda declaration, if the object that needs to be capture is not very big, capture it by value, and if you want to mutate the object that you capture, capture it by reference.
